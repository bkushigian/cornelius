package serializer.peg;

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;

import java.io.*;
import java.nio.file.Paths;
import java.util.*;
import serializer.XMLGenerator;

/**
 * This class provides a CLI to serialize a program and its mutants into an XML file.
 */
public class PegSubjectSerializer {
    boolean printDerefStrings = false;

    public static void main(String[] args) {
        if (args.length < 2) {
            usage("Incorrect arg count");
        }
        /* arg[0] is original program; arg[1] is folder of mutated copies; args[2] is log of mutations */
        final PegSubjectSerializer m =  new PegSubjectSerializer(
                String.format("%s/%s", args[0], args[1]),
                String.format("%s/mutants", args[0]),
                String.format("%s/mutants.log", args[0]));

        m.parseArgs(args);
        m.run();
    }

    private void parseArgs(String[] args) {
        for (String arg : args) {
            if ("--print-pegs".equals(arg)) {
                printDerefStrings = true;
                break;
            }
        }
    }

    /**
     * The path of the original programs Java source code
     */
    final String origPath;

    /**
     * The path to the mutants directory generated by Major. This directory should only contain subdirectories
     * 1, 2, 3, ..., n, where each subdirectory {@code i} is titled after the mutant-id of the mutant it contains.
     * That is, directory 17 contains the mutant with mutant id 17 as documented in the {@code mutants.log} file.
     */
    final String mutantsPath;

    /**
     * The path to {@code mutants.log}
     */
    final String logPath;

    public PegSubjectSerializer(final String orig, final String mutants, final String logPath) {
        origPath = orig;
        mutantsPath = mutants;
        this.logPath = logPath;
    }

    /**
     * Serialize a SIMPLE Java program's Peg representation
     */
    public void run() {
        try {
            final CompilationUnit cu = StaticJavaParser.parse(new File(origPath));
            final MutantsLog mutantsLog = new MutantsLog(logPath);
            final XMLGenerator xmlGen = new XMLGenerator();
            final SimpleJavaToPegTranslator translator = new SimpleJavaToPegTranslator();

            final Map<String, PegNode> methodMap = translator.translate(cu);

            // Iterate through each method
            for (String sig : mutantsLog.methodNameMap.keySet()){
                final String canonical = Util.canonicalName(sig);
                final String sourceFile = sig.substring(0, sig.indexOf('@')).replace('.', '/') + ".java";
                xmlGen.addSubject(origPath, sig, methodMap.get(canonical).id);

                System.out.println("================================================================================");
                System.out.println("[+] Visiting method signature: " + sig);
                System.out.println("[+] Source file: " + sourceFile);
                System.out.println("[+] Name: " + canonical);

                final Set<MutantsLog.Row> rows = mutantsLog.methodNameMap.get(sig);
                if (printDerefStrings) {
                    System.out.printf("original: %s\n", methodMap.get(canonical).toDerefString());
                }

                for (MutantsLog.Row row : rows) {
                    final Set<File> javaFiles = new HashSet<>();
                    collectJavaFiles(new File(Paths.get(mutantsPath, row.id).toString()), javaFiles);
                    if (javaFiles.size() != 1) {
                        System.err.println(Arrays.toString(javaFiles.toArray()));
                        throw new IllegalStateException(
                                String.format("Mutant root %s contained %d java files, expected1",
                                        Paths.get(mutantsPath, row.id).toString(),
                                        javaFiles.size()));
                    }

                    try {
                        final CompilationUnit mcu = StaticJavaParser.parse(javaFiles.iterator().next());
                        try {
                            row.pegId = translator.translate(mcu, canonical)
                                    .orElseThrow(() -> new RuntimeException("Couldn't find mutant"))
                                    .id;
                        } catch (IllegalStateException e) {
                          System.err.println("erroneous mutant id: " + row.id);
                          throw e;
                        }

                        xmlGen.addMutant(sig, row.id, row.pegId);
                        if (printDerefStrings) {
                            System.out.printf("mutant %s: %s\n", row.id, PegNode.getIdLookup().get(row.pegId).toDerefString());
                        }

                    } catch (FileNotFoundException e) {
                        throw new RuntimeException("Couldn't parse mutant " + row.id);
                    }
                }
            }

            xmlGen.addDeduplicationTable(PegNode.getIdLookup());

            xmlGen.writeToFile("subjects.xml");
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            System.err.println("Couldn't write subjects.xml");
        }
    }

    /**
     * Print an error message and usage info to stderr and exit with status 1.
     * @param msg error message to print to stderr
     */
    static void usage(final String msg) {
        System.err.println(msg);
        System.err.println("usage: Main dir java_file [ARGS...]");
        System.err.println("    - dir: Base directory of subject. This should contain the java file, mutants, and " +
                "mutants.log");
        System.err.println("    - java_file: name of the java file to be compiled");
        System.err.println("ARGS");
        System.err.println("----");
        System.err.println("    --print-pegs: Print each PEG");

        System.exit(1);
    }

    /**
     * This class represents the {@code mutants.log} file. In particular, this comprises a list of {@code Row}s as
     * well as two convenience data structures:
     *
     * <ol>
     *     <li>A map from mutant id to its corresponding {@code Row}</li>
     *     <li>A map from method name to a {@code Set<Row>}} containing all {@code Row}s corresponding to a mutation
     *         of the method</li>
     * </ol>
     *
     */
    public static class MutantsLog {

        /**
         * {@code idMap} maps mutant Ids (in a {@code String} form, i.e. "1", "2", ...) to the corresonding {@code Row}
         * object that was parsed from {@code mutants.log}
         */
        public final Map<String, Row> idMap;

        /**
         * {@code methodNameMap} maps method names to the set of mutants that mutate the method.
         */
        public final Map<String, Set<Row>> methodNameMap;

        /**
         * A list of all rows from {@code mutants.log}
         */
        public final List<Row> rows;

        final String logPath;

        MutantsLog(final String logPath) {
            this.logPath = logPath;
            idMap = new HashMap<>();
            methodNameMap = new HashMap<>();
            rows = new ArrayList<>(128);

            // Read in mutants.log, creating Row objects
            try (BufferedReader br = new BufferedReader(new FileReader(logPath))) {
                String line;
                while ((line = br.readLine()) != null) {
                    final Row r = new Row(line);
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        /**
         * Represent a row from {@code mutants.log}
         */
        public class Row {

            /**
             * Mutant id generated by Major (i.e., {@code "1"}, {@code "2"}, ...
             */
            public final String id;

            /**
             * Mutation type (AOR, etc)
             */
            public final String mutationType;

            /**
             * The original unmutated node
             */
            public final String originalNode;

            /**
             * The mutated node
             */
            public final String mutantNode;

            /**
             * Fully qualified method signature: "Class@name(arg,types)"
             */
            public final String method;

            /**
             * Source code line number the mutant occurred at
             */
            public final int lineNumber;

            /**
             * String describing the transformation: {@code a + b |===> a - b}
             */
            public final String transformation;

            /**
             * A string representation of this mutants AST. This is computed by a visitor
             */
            public String ast;

            /**
             * Representation of the peg id that we generated while constructing the peg node
             */
            public int pegId;

            /**
             * Create a new {@code Row} from a line of raw text and enter the resulting values into {@code MutantsLog}
             * data structures.
             *
             * @param raw raw String from the log representing the row
             */
            Row(String raw) {
                final String[] items = raw.split(":");
                assert items.length == 7;
                id = items[0];
                mutationType = items[1];
                originalNode = items[2];
                mutantNode = items[3];
                method = items[4];
                lineNumber = Integer.parseInt(items[5]);
                transformation = items[6];

                rows.add(this);
                idMap.put(id, this);
                methodNameMap.putIfAbsent(method, new HashSet<>());
                methodNameMap.get(method).add(this);
            }

            @Override
            public String toString() {
                return "Row{" +
                        "id='" + id + '\'' +
                        ", mutationType='" + mutationType + '\'' +
                        ", originalNode='" + originalNode + '\'' +
                        ", mutantNode='" + mutantNode + '\'' +
                        ", method='" + method + '\'' +
                        ", lineNumber=" + lineNumber +
                        ", transformation='" + transformation + '\'' +
                        '}';
            }
        }
    }

    /**
     * Recursively visit a directory structure and collect all Java files
     * @param file root of file tree to explore: can be a File or a Directory
     * @param javaFiles set that will be modified to hold all java files. If null, a new set will be created for you.
     * @return The set with collected Java files
     */
    private Set<File> collectJavaFiles(final File file, final Set<File> javaFiles) {
        if (file == null) {
            throw new IllegalArgumentException("Parameter `file` in `collectJavaFiles` is `null`");
        }
        if (javaFiles == null) {
            return collectJavaFiles(file, new HashSet<>());
        }
        if (!file.isDirectory()) {
            if (file.getName().endsWith(".java")) {
                javaFiles.add(file);
            }
            return javaFiles;
        }
        final File[] files = file.listFiles();
        assert files != null;                  // This must hold since file.isDirectory()
        for (File f : files) {
            collectJavaFiles(f, javaFiles);
        }
        return javaFiles;
    }
}
